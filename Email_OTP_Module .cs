using System;

using System.IO;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Threading.Tasks;
namespace Coding_Assessment_Test_Faez
{
    enum STATUS_EMAIL
    {
        STATUS_EMAIL_OK,
        STATUS_EMAIL_FAIL,
        STATUS_EMAIL_INVALID
    }

    enum STATUS_OTP
    {
        STATUS_OTP_OK,
        STATUS_OTP_FAIL,
        STATUS_OTP_TIMEOUT
    }
    class Email_Fail_Exception : Exception { }

    class iostream : Stream
    {
        public override bool CanRead => throw new NotImplementedException();

        public override bool CanSeek => throw new NotImplementedException();

        public override bool CanWrite => throw new NotImplementedException();

        public override long Length => throw new NotImplementedException();

        public override long Position { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

        public string readOTP()
        {
            return Console.ReadLine();
        }

        public override void Flush()
        {
            throw new NotImplementedException();
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            throw new NotImplementedException();
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotImplementedException();
        }

        public override void SetLength(long value)
        {
            throw new NotImplementedException();
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotImplementedException();
        }
    }
    class Email_OTP_Module
    {
        const string ALLOWED_DOMAIN = ".dso.org.sg";
        string OTP;
        void start()
        {
        }

        /* close can be called after an instance of Email OTP is to be remove from the application.
         */
        void close()
        {
            //optional to implement
        }

        /*
        @func generate_OTP_email sends a new 6 digit random OTP code to the given email address input by the users. Only emails from the ".dso.org.sg" domain should be allowed to receive an OTP code.
        You can assume a function send_email(email_address, email_body) is implemented. 
        Email body to the user should be in this format "You OTP Code is 123456. The code is valid for 1 minute"

        @param user_email is an email address entered by the user. 

        @returns the following status code (assume implemented as constants)
        STATUS_EMAIL_OK: email containing OTP has been sent successfully.
        STATUS_EMAIL_FAIL: email address does not exist or sending to the email has failed.
        STATUS_EMAIL_INVALID: email address is invalid.
        */
        public STATUS_EMAIL generate_OTP_email(string user_email)
        {
            //implement med
            if (user_email.Length<ALLOWED_DOMAIN.Length ||
                user_email.Substring(user_email.Length-ALLOWED_DOMAIN.Length)!=ALLOWED_DOMAIN){
                return STATUS_EMAIL.STATUS_EMAIL_INVALID;
            }
            using (var _rng = RandomNumberGenerator.Create())
            {
                byte[] _RNGBytes = new byte[4];
                _rng.GetBytes(_RNGBytes);
                string _rngRes = BitConverter.ToUInt32(_RNGBytes, 0).ToString("D6");
                OTP = _rngRes.Substring(_rngRes.Length - 6);
            }
            string email_body = "Your OTP Code is "+OTP+". The code is valid for 1 minute";
            try
            {
                send_email(user_email, email_body);
            }
            catch (Email_Fail_Exception)
            {
                return STATUS_EMAIL.STATUS_EMAIL_FAIL;
            }
            return STATUS_EMAIL.STATUS_EMAIL_OK;
        }
        void send_email(string user_email, string email_body)
        {
            if(user_email.Equals("fail.dso.org.sg"))
            {
                throw new Email_Fail_Exception();
            }
            Console.WriteLine(email_body);
        }
        /*
        @func check_OTP reads the input stream for user input of the OTP. The OTP to match is the current OTP generated by a send
        allows user 10 tries to enter the valid OTP. check_OTP should return after 1min if the user does not give a valid OTP. 

        @param input is a generic IOstream. It implements input.readOTP() which waits and returns the 6 digit entered by the user. this function call is blocking so you might need to wrap it in a timeout.

        @returns the following status code (assume implemented as constants)
        STATUS_OTP_OK: OTP is valid and checked
        STATUS_OTP_FAIL: OTP is wrong after 10 tries
        STATUS_OTP_TIMEOUT: timeout after 1 min
        */
        public STATUS_OTP check_OTP(iostream input)
        {
            STATUS_OTP status = STATUS_OTP.STATUS_OTP_OK;
            var _task = Task.Run(()=> {
                int _attempts = 0;
                string _otp = "";
                while (!_otp.Equals(OTP))
                {
                    if (_attempts == 10)
                    {
                        status = STATUS_OTP.STATUS_OTP_FAIL;
                        break;
                    }
                    _otp = input.readOTP();
                    _attempts++;
                }
            });
            Stopwatch sw = Stopwatch.StartNew();
            while (!_task.IsCompleted)
            {
                if (sw.Elapsed.TotalMilliseconds>60*1000)
                {
                    status = STATUS_OTP.STATUS_OTP_TIMEOUT;
                    break;
                }
            }
            return status;
        }
    }
}
